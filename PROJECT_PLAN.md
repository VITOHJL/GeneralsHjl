# Generals.io 游戏开发计划

## 项目概述

这是一个基于 generals.io 游戏规则的本地单机游戏项目。玩家可以在本地与AI机器人对战，体验经典的策略游戏玩法。

## 项目目标

### 第一阶段：核心游戏逻辑（本地单机）
- [x] 项目初始化和规划
- [ ] 游戏地图生成系统
- [ ] 游戏规则实现
- [ ] 基础UI界面
- [ ] 玩家操作交互
- [ ] AI机器人对手

### 第二阶段：游戏功能完善
- [ ] 多种地图尺寸
- [ ] 难度等级设置
- [ ] 游戏统计和回放
- [ ] 音效和动画
- [ ] 游戏设置界面

### 第三阶段：上线部署（可选）
- [ ] 联机功能
- [ ] 多人在线对战
- [ ] 用户系统
- [ ] 排行榜

## 技术栈

### 推荐技术栈：React + Node.js + TailwindCSS + SQLite

#### 技术栈选择分析

**React + Node.js + TailwindCSS + SQLite** 技术栈的优缺点：

##### 优点 ✅

1. **技术栈统一**
   - 前后端都使用 JavaScript，代码复用性高
   - 开发人员只需掌握一种语言
   - 共享类型定义和工具函数

2. **React 优势**
   - 组件化开发，代码结构清晰
   - 丰富的生态系统（React Router, Redux, Zustand等）
   - 虚拟DOM，性能优化好
   - 适合复杂UI交互
   - 社区活跃，资源丰富

3. **Node.js 优势**
   - 即使单机游戏，也可以用于：
     - 游戏逻辑服务端验证（防止作弊）
     - AI计算（复杂AI算法可以放在服务端）
     - 游戏回放和统计
   - 未来扩展联机功能时无缝对接
   - 丰富的npm包生态

4. **TailwindCSS 优势**
   - 快速开发，无需写大量CSS
   - 响应式设计简单
   - 样式一致性好
   - 打包时自动去除未使用的样式

5. **SQLite 优势**
   - 轻量级，无需单独数据库服务器
   - 适合本地存储游戏数据、回放、统计
   - 文件数据库，部署简单
   - 支持SQL，查询灵活

##### 缺点 ❌

1. **复杂度增加**
   - 相比纯前端方案，需要搭建前后端架构
   - 需要处理前后端通信
   - 开发环境配置更复杂

2. **性能考虑**
   - React的虚拟DOM在简单场景可能过度设计
   - 对于纯Canvas游戏，React可能不是最优选择
   - 可以考虑React + Canvas混合方案

3. **SQLite限制**
   - 并发写入性能有限（但单机游戏影响不大）
   - 不适合大规模数据（但游戏数据量不大）

4. **学习曲线**
   - 需要掌握React、Node.js、SQLite
   - 但你已经熟悉这套技术栈，这不是问题

##### 建议方案

**当前阶段（单机游戏）：**
- **前端**: React + TailwindCSS + Canvas（React管理UI，Canvas渲染游戏）
- **后端**: Node.js（可选，用于AI计算、游戏逻辑验证）
- **数据库**: SQLite（存储游戏回放、统计数据）

**未来扩展（联机功能）：**
- **后端**: Node.js + Express + WebSocket
- **数据库**: SQLite（小规模）或 PostgreSQL（大规模）

##### 替代方案对比

| 方案 | 优点 | 缺点 | 适用场景 |
|------|------|------|----------|
| **纯前端（HTML+Canvas+JS）** | 简单、快速、无需后端 | 无法做复杂AI、无数据持久化 | 简单单机游戏 |
| **React+Node.js+SQLite** | 技术栈统一、易扩展、功能完整 | 复杂度较高 | **推荐：功能完整的游戏** |
| **Vue+Node.js+SQLite** | 学习曲线平缓 | 生态系统略小 | 团队更熟悉Vue时 |

### 最终推荐

**采用 React + Node.js + TailwindCSS + SQLite**

理由：
1. 你已经熟悉这套技术栈
2. 即使单机游戏，Node.js也可以用于AI计算和数据处理
3. SQLite可以存储游戏回放、统计数据
4. 未来扩展联机功能时无需重构
5. React组件化适合游戏UI管理

### 技术栈详细

#### 前端
- **React 18+** - UI框架
- **TailwindCSS** - 样式框架
- **Canvas API** - 游戏渲染（可以在React组件中使用）
- **React Router** - 路由（如果需要多页面）
- **Zustand/Redux** - 状态管理（游戏状态）

#### 后端（当前阶段可选）
- **Node.js** - 运行环境
- **Express** - Web框架（如果需要API）
- **SQLite3** - 数据库

#### 开发工具
- **Vite** - 构建工具（推荐，比Webpack快）
- **ESLint** - 代码检查
- **Prettier** - 代码格式化

## 游戏规则

### 术语定义

- **tile（格子）**: 地图上的基本单位
- **unit（单位）**: 一个格子内军队的数量
- **stronghold/city（要塞/城市）**: 提供额外军队增长的特殊格子
- **capital（首都）**: 玩家的起始点，被占领即失败
- **mountain（山区）**: 不可通过的障碍物
- **swamp（沼泽）**: 每回合消失1个单位的特殊格子
- **blank（空地）**: 普通可占领的格子
- **turn（回合）**: 游戏时间单位
- **half-turn（半回合）**: 每回合包含2个半回合

### 简化版本规则（第一阶段实现）✅

#### 1. 地图结构
- 网格地图（如 25x25, 30x30 等）
- 每个格子类型：
  - **空地（Blank）** - 可占领，初始可能有中立单位
  - **山区（Mountain）** - 不可通过，不可占领
  - **要塞（Stronghold/City）** - 可占领，每回合+2单位
  - **首都（Capital）** - 玩家起始点，被占领即失败，每回合+1单位
  - ~~沼泽（Swamp）~~ - **简化版暂不实现**

#### 2. 时间系统（简化）
- **回合制**：每回合玩家可以移动一次
- ~~半回合系统~~ - **简化版：每回合移动一次，不做半回合**
- ~~任务队列~~ - **简化版：即时操作，不做队列**

#### 3. 军队系统
- 每个己方格子每**轮**（25回合）产生1个单位
- 要塞每回合产生1个单位
- 首都每回合产生1个单位
- ~~沼泽每回合消失1个单位~~ - **简化版暂不实现**

#### 4. 移动规则

**基本规则**：
- 只能从己方格子移动
- 移动到相邻的4个方向（上下左右，曼哈顿距离为1）
- 不能移动到山区
- 移动时必须在原格子留下至少1个单位

**操作方式**（UX优化）：
- **点击+点击**：点击源格子 → 点击目标格子
  - 移动50%兵力（向下取整）
  - 例如：源格子有10个单位，移动5个，留下5个
  
- **点击+拖拽**：点击源格子 → 拖拽到目标格子
  - 只保留1个单位，其余全部移动
  - 例如：源格子有10个单位，移动9个，留下1个

**操作反馈**：
- 点击源格子时，高亮显示该格子
- 拖拽时显示移动路径和预览
- 点击目标格子时显示移动数量预览

#### 5. 战斗规则
- **移动到空地**：花费1个单位即可占领
- **移动到敌方格子**：
  - 攻击方单位数 > 防御方：占领，剩余 = 攻击方 - 防御方
  - 攻击方单位数 = 防御方：双方都消失，格子变为空地
  - 攻击方单位数 < 防御方：攻击失败，防御方剩余 = 防御方 - 攻击方
- **移动到己方格子**：单位数相加

#### 6. 胜利条件
- 占领敌方首都
- ~~消灭所有敌方军队~~ - **简化版：只判断首都**

#### 7. 视野系统（简化）
- ~~迷雾系统~~ - **简化版：全地图可见（Crystal Clear模式）**
- 完整版将实现：
  - 只能看到己方占领格子周围1格（切比雪夫距离≤1）
  - 未探索区域显示为迷雾

---

### 完整版本规则（后续实现）📋

#### 1. 时间系统（完整版）

**半回合系统**：
- 每回合包含2个半回合
- 玩家每半回合可以移动一次（即每回合2次）
- 使用任务队列管理操作

**任务队列**：
- 每个玩家有独立的任务队列
- 操作类型：
  - 计划操作：向队列末尾添加移动
  - 清空队列：清空所有计划
  - 撤销队尾：删除最后一个操作
- 如果操作不合法，队列会被清空

**移动优先级**：
- 玩家之间的移动优先级每半回合交替
- 当前最优先的玩家在交替后变为最低优先级
- 其他玩家优先级顺次增加

#### 2. 军队系统（完整版）

- **普通格子**：每轮（25回合）产生1个单位
- **要塞**：每回合产生1个单位
- **首都**：每回合产生1个单位
- **沼泽**：每回合消失1个单位
- **中立格子**：不自动产生单位

#### 3. 视野系统（完整版）

**视野范围**：
- 地图上全部明示的格子（除非启用Misty Veil）
- 与己方占领格子切比雪夫距离≤1的格子

**视野信息**：
- 视野内：显示格子类型、占领方、军队数量
- 视野外：只显示部分信息
  - 疑似空地：空地或首都
  - 疑似山区：山区或要塞
  - 沼泽：沼泽

#### 4. 特殊规则（完整版）

- **Leapfrog（蛙跳）**：占领敌方首都后，自己的首都迁移到该位置
- **City-State（城邦）**：开局时每个玩家旁边生成一个要塞
- **Misty Veil（迷雾面纱）**：限制视野范围
- **Crystal Clear（清晰视野）**：移除战争迷雾
- **Silent War（静默战争）**：移除队伍排名和通知

#### 5. 队伍系统（完整版）

- 支持多玩家组队
- 队伍内玩家共享视野
- 队伍排名系统
- 队友之间可以合并单位

#### 6. 玩家掉线处理（完整版）

- 掉线玩家的单位变为中立单位
- 或转移给最近的队友

---

### 地图生成规则

#### 简化版地图生成 ✅

**基本要求**：
- 地图大小：5×5 到 255×255
- 确保空地连通（将山区和要塞视为障碍）
- 至少16个空地
- 玩家首都不相邻

**生成步骤**：
1. 随机放置山区
2. 确保空地连通（可能需要移除部分山区）
3. 在山区中随机选择部分变为要塞
4. 在空地中随机选择玩家首都位置（不相邻）

#### 完整版地图生成 📋

**参数**：
- `city_dense`: 要塞密度 (0-255)
- `mountain_dense`: 山区密度 (0-255)
- `swamp_dense`: 沼泽密度 (0-255)
- `light_dense`: 明示格子密度 (0-255)

**生成算法**：
1. 根据密度计算各类型格子数量
2. 随机放置山区
3. 确保连通性
4. 在山区中选择部分变为要塞
5. 在空地中选择部分变为沼泽
6. 随机选择明示格子
7. 分配玩家首都（考虑队伍）

**首都分配算法**：
- 势力染色分配：为每个队伍分配势力核心，然后分配首都
- 最小配对分配：最小化队友首都之间的距离

---

### 实现优先级

#### Phase 1: 简化版核心功能 ✅
- [x] 基础地图生成（空地、山区、要塞、首都）
- [ ] 回合制系统（每回合移动一次）
- [ ] 军队增长系统（每轮+1，要塞每回合+1）
- [ ] 移动和战斗系统
- [ ] 胜利判定（占领首都）
- [ ] 全地图可见（无迷雾）

#### Phase 2: 完善游戏体验 📋
- [ ] 半回合系统
- [ ] 任务队列
- [ ] 移动优先级
- [ ] 沼泽系统
- [ ] 基础AI机器人

#### Phase 3: 高级功能 📋
- [ ] 迷雾系统
- [ ] 视野计算
- [ ] 队伍系统
- [ ] 特殊规则
- [ ] 游戏回放

---

### 参考文档

详细的技术文档参考：Generals IO技术文档（已提供）

**注意**：当前阶段先实现简化版本，确保核心玩法能够运行，后续逐步完善功能。

## 项目结构

### React + Node.js 项目结构

```
generals.io/
├── frontend/                    # React 前端
│   ├── public/
│   │   └── index.html
│   ├── src/
│   │   ├── components/          # React 组件
│   │   │   ├── GameCanvas/      # 游戏画布组件
│   │   │   ├── GameUI/          # 游戏UI组件
│   │   │   ├── Menu/            # 菜单组件
│   │   │   └── Settings/        # 设置组件
│   │   ├── game/                # 游戏核心逻辑
│   │   │   ├── GameEngine.js    # 游戏引擎
│   │   │   ├── MapGenerator.js  # 地图生成
│   │   │   ├── Player.js        # 玩家类
│   │   │   ├── AI.js            # AI机器人
│   │   │   └── Renderer.js      # Canvas渲染器
│   │   ├── store/               # 状态管理（Zustand）
│   │   │   └── gameStore.js
│   │   ├── utils/               # 工具函数
│   │   ├── App.jsx
│   │   └── main.jsx
│   ├── package.json
│   └── tailwind.config.js
│
├── backend/                     # Node.js 后端（可选）
│   ├── src/
│   │   ├── routes/              # API路由
│   │   ├── services/            # 业务逻辑
│   │   │   ├── gameService.js   # 游戏逻辑服务
│   │   │   └── aiService.js     # AI计算服务
│   │   ├── models/              # 数据模型
│   │   └── server.js            # 服务器入口
│   ├── database/
│   │   └── init.sql             # SQLite初始化
│   └── package.json
│
├── shared/                      # 共享代码（前后端共用）
│   └── types/                   # TypeScript类型定义（可选）
│
├── README.md
├── PROJECT_PLAN.md
└── package.json                 # 根package.json（workspace）
```

### 简化版项目结构（Phase 1）

如果先做纯前端版本：

```
generals.io/
├── public/
│   └── index.html
├── src/
│   ├── components/
│   │   ├── GameCanvas.jsx
│   │   └── GameUI.jsx
│   ├── game/
│   │   ├── GameEngine.js
│   │   ├── MapGenerator.js
│   │   ├── Player.js
│   │   ├── AI.js
│   │   └── Renderer.js
│   ├── store/
│   │   └── gameStore.js
│   ├── App.jsx
│   └── main.jsx
├── package.json
├── tailwind.config.js
├── vite.config.js
├── README.md
└── PROJECT_PLAN.md
```

## 开发阶段

### Phase 1: 基础框架（1-2周）

#### 1.1 项目结构搭建
- [ ] 创建HTML基础页面
- [ ] 设置Canvas画布
- [ ] 基础CSS样式
- [ ] 模块化JavaScript结构

#### 1.2 地图系统
- [ ] 地图数据结构设计
- [ ] 地图生成算法（随机生成）
- [ ] 地图渲染（基础）
- [ ] 格子类型定义（空地、山脉、城市、将军）

#### 1.3 游戏状态管理
- [ ] 游戏状态机（开始、进行中、结束）
- [ ] 回合系统
- [ ] 玩家数据管理

### Phase 2: 核心玩法（2-3周）

#### 2.1 玩家操作
- [ ] 鼠标点击选择格子
- [ ] **点击+点击**：移动50%兵力
- [ ] **点击+拖拽**：只保留1个，其余全部移动
- [ ] 移动命令执行
- [ ] 攻击命令
- [ ] 操作验证
- [ ] 操作反馈（高亮、预览）

#### 2.2 游戏逻辑
- [ ] 军队增长系统
- [ ] 战斗系统
- [ ] 占领系统
- [ ] 胜利判定

#### 2.3 基础AI
- [ ] 简单随机移动AI
- [ ] 基础策略AI（寻找敌人、扩张）
- [ ] AI难度等级

### Phase 3: 界面和体验（1-2周）

#### 3.1 UI界面
- [ ] 游戏菜单
- [ ] 游戏设置界面
- [ ] 游戏结束界面
- [ ] 信息显示（军队数、回合数等）

#### 3.2 视觉效果
- [ ] 地图美化
- [ ] 动画效果（移动、战斗）
- [ ] 颜色主题
- [ ] 响应式设计

#### 3.3 音效（可选）
- [ ] 背景音乐
- [ ] 操作音效
- [ ] 战斗音效

### Phase 4: 优化和扩展（1-2周）

#### 4.1 功能扩展
- [ ] 多种地图尺寸
- [ ] 游戏回放功能
- [ ] 统计信息
- [ ] 快捷键支持

#### 4.2 性能优化
- [ ] 渲染优化
- [ ] 内存管理
- [ ] 代码优化

#### 4.3 测试和修复
- [ ] 游戏平衡性测试
- [ ] Bug修复
- [ ] 用户体验优化

## AI机器人设计

### 简单AI（Easy）
- 随机移动
- 不主动攻击
- 基础防御

### 中等AI（Medium）
- 优先扩张领土
- 寻找并攻击弱小的敌人
- 保护自己的将军

### 困难AI（Hard）
- 战略规划
- 优先占领城市
- 主动寻找敌方将军
- 多线作战

### 专家AI（Expert）
- 深度策略分析
- 预测玩家行为
- 最优路径规划
- 资源管理优化

## 技术难点

1. **地图生成算法**
   - 确保地图平衡性
   - 合理分布城市和山脉
   - 玩家起始位置公平

2. **路径查找算法**
   - A*算法用于AI寻路
   - 最短路径计算

3. **游戏状态同步**
   - 确保所有操作的一致性
   - 状态回滚（如果需要）

4. **性能优化**
   - 大量格子的渲染优化
   - 动画流畅度

## 开发工具

- **代码编辑器**: VS Code
- **版本控制**: Git + GitHub
- **调试工具**: Chrome DevTools
- **设计工具**: Figma（可选，用于UI设计）

## 时间估算

- **Phase 1**: 1-2周
- **Phase 2**: 2-3周
- **Phase 3**: 1-2周
- **Phase 4**: 1-2周

**总计**: 5-9周（根据开发时间投入）

## 下一步行动

1. ✅ 完成项目规划文档
2. ⏭️ 创建基础HTML页面和Canvas
3. ⏭️ 实现地图生成系统
4. ⏭️ 实现基础渲染
5. ⏭️ 实现玩家操作
6. ⏭️ 实现游戏核心逻辑
7. ⏭️ 添加AI机器人
8. ⏭️ 完善UI和体验

## 参考资料

- [Generals.io 官方网站](https://generals.io)
- [Generals.io 游戏规则](https://generals.io/help)
- Canvas API 文档
- JavaScript 游戏开发最佳实践

## 注意事项

- 保持代码模块化，便于维护和扩展
- 注重用户体验，界面简洁易用
- 游戏平衡性很重要，需要反复测试
- 性能优化要持续进行
- 代码要有良好的注释

---

**最后更新**: 2025-01-23
**项目状态**: 规划阶段

